This text is a rough overview over the Wrowser and the backend
openwns.wrowser.probeselector for developers.

The Wrowser is a tool to display graphs generated from openWNS simulation data. The
data can be fetched from
- probe files in a directory tree (no campaign),
- a csv file describing a simulation campaign located in directories,
- any sqlobject supported database containing a simulation campaign or
- a Postgres database containing multiple campaigns from multiple users.

There a two different ways a graph can be constructed:
- Get a complete graph from each scenario. This is the method used for the 
  histogram-/time-log-graphs from LogEval, PDF-, (D)LRE and BatchMeans-probes.
- Get one graph point from each scenario. This is used for parameter graphs.

Generating those graphs is not the task of Wrowser. They are generated by the
backend. Wrowser only provides a user interface and forwards the graphs
to matplotlib, which is used to show them.

THE WROWSER.PROBESELECTOR BACKEND
The backend's tasks are:
- Access campaign data from diffierent data sources.
- Represent the fetched campaign data.
- Provide algorithms to acquire information from the campaign data.

The access to data sources is done in the *Readers.py-files. A CampaignReader
from one of these files provides the basic campaign data: a list of the
names of the parameters that were varied across the scenarios and a list of
ScenarioReaders to access the scenarios.

The Scenario- and ProbeReaders serve as read-on-demand source for the
representation classes. These are located in Representations.py and their
single purpose is to represent the data they fetch via their readers once
it is first accessed.

The algorithms to operate on these representations are found in the class
Interface.Facade. This class contain a lot of methods to gather different
sorts of information from the campaign. Graphs are generated with its
acquireGraph method (the getGraphs, getHistograms and getLogEvalEntries
methods are for backward compatibility with Wrowser 0.3), which itself
uses the package dataacquisition.

The dataacquisition package acquires the graph data from the scenarios.
The class Scenario (found in __init__.py) iterates over the scenarios and
uses a class from either Probe.py or Compose.py to fetch data from it.
The classes in Probe.py create a complete graph from a scenario, the classes
in Compose.py just add one point for each scenario.

As a simple usage example let's create a graph from the system tests directory.

> import wnsrc

Construct a CampaignReader:
> from openwns.wrowser.probeselector import DirectoryReaders
> reader = DirectoryReaders.CampaignReader("tests/system")
> scenarioReaders, parameterNames = reader.read()
> print parameterNames
: ['directory']
As you see, this "campaign" only has a pseudo-parameter called directory.
Each subdirectory is considered to be a scenario.

Setup the campaign representation:
> from openwns.wrowser.probeselector import Representations
> campaign = Campaign(scenarioReaders, parameterNames)

Wrap the Facade around:
> from openwns.wrowser.probeselector import Interface
> facade = Interface.Facade(campaign)

We could now use facade.filteredBy* to get a facade with a campaign that
has a reduced number of scenarios, but we won't do this, because we can
not filter anything senseful with our pseudo-parameter "directory".

Show all values of the parameter:
> directories = facade.getValuesOfParameter("directory")
> for directory in directories: print directory
This will list all directories where probes have been found.

Show all probe names:
> probeNames = facade.getProbeNames().union
> for probeName in probeNames: print probeName

Show all LogEval probe names:
> import openwns.wrowser.Probe
> for probeName in facade.getProbeNames(openwns.wrowser.Probe.LogEvalProbe).union: print probeName

Let's create a LogEval graph now.
First create a probe data acquirer:
> from openwns.wrowser.probeselector.dataacquisition import Probe
> probeDataAcquirer = Probe.LogEval()

If we had opened a real campaign, we could draw a parameter graph with
probeDataAcquirer = Compose.XY(x = Compose.ParameterValue("foo"), y = Compose.ProbeEntry("mean"))
or probeDataAcquirer = Compose.XY(x = Compose.ProbeEntryOfProbe("aProbeName", "mean"), y = Compose.ProbeEntry("mean"))

Next setup a scenario data acquirer:
> from openwns.wrowser.probeselector.dataacquisition import Scenario
> scenarioDataAcquirer = Scenario(probeDataAcquirers = {"glue.berLevel_wns.node.Node.id1_SC1_Log.dat" : probeDataAcquirer},
>                                 parameterNames = list(facade.getChangingParameterNames()))
Now get the graphs:
> graphs, errors = facade.acquireGraphs(scenarioDataAcquirer)
> for error in errors: print errors
As you will see, the probe we selected is not available in all "scenarios".
> for graph in graphs: print graph.identity

Last but not least export the graphs:
> from openwns.wrowser.probeselector import Exporters
> Exporters.CSV.export("/tmp/graphs.csv", graphs)
> cat /tmp/graphs.csv

THE WROWSER ITSELF
The code of Wrowser is divided into files by following rules:
- Models for Qt's model/view concept are in Models.py.
- Widgets that are Dialogues are in Dialogues.py.
- Widgets that are to be used as Windows but aren't Dialogues are in Windows.py.
- Widgets that are to be used as Widgets inside Windows/Dialogues are in
  Widgets.py.
- The directory ui contains Qt's .ui files and python files generated by pyuic.
  .ui files' names resemble the class' name, e.g. Widgets_Graph.ui.
  The name attribute of the outermost widget element in the ui file is the same
  as the file name (This is the name of the form in Qt designer).
- Data.py contains support classes representing data.
- Debug.py contains debug support classes.
- Tools.py contains other support classes.

The main window of Wrowser is Windows.Main. After opening of a data source
a dock widget will be created, either Windows.SimulationParameters or
Windows.DirectoryNavigation. The dock widget holds the campaign data wrapped by
a Facade. The SimulationParameters window has three campaigns:
- "original": as read from the data source
- "expressionFiltered": filtered from "original" using Facade.filteredByExpression
- "draw": filtered from "expressionFiltered" using Facade.filteredBySelection
DirectoryNavigation provides only the draw campaign.

All Figure windows are derived from Windows.Figure. Windows.Figure is a very
simple window with two QWidgets, a QSplitter in between and the buttons
"Draw", "Export" and "Configure" at the bottom.
The right window is meant to display the graph, the left to control how it is
drawn.

Classes deriving from Windows.Figure fill these widgets with widgets appropriate
for their task.
In the right half figure windows displaying a line graph will show a
Widgets.LineGraph and a Widgets.Legend, Windows.TableFigure will display
Widgets.TableGraph.
In the left half probe figure windows will display Widgets.ProbeGraphControl,
Windows.ParameterFigure will show Widgets.ParameterGraphControl.

Some objects in Wrowser are observable and some are observing using the
corresponding classes in Tools.py. E.g. the campaigns are observable and
the Figure windows oberve it, Data.Figure is observable and Widgets.LineGraph
observes it. New graphs are drawn simply by assigning them to
Widgets.LineGraph.figureConfig.graphs.

